#+title: Evaluación del primer proyecto (monitor de sistema)
#+author: Gunnar Wolf

* Alberto Díaz

- Directorio de entrega :: [[./AlbertoDiaz/]]
- Documentación :: [[./AlbertoDiaz/readme.md]]
- Lenguaje de desarrollo :: Python
- Uso primario de sincronización :: Señalización
- Observaciones ::
  - Hay información de la que tienes /garantía/ que será estable, a
    pesar de lo cual lees repetidamente. Por ejemplo, la información
    que entrega tu función =watchProc()= no puede casi que por
    definición cambiar sin que apagues la computadora, al igual que no
    lo hará =watchVersion()=. ¿Por qué pasar diez veces por el ciclo
    sobre =contador=, con diez =sleep= de un segundo?
  - Desde un programa, llamar a =cat= como programa para averiguar el
    contenido de un archivo (como lo haces en varias ocasiones) es un
    desperdicio burocrático de recursos... E incluso puede verse, en
    la circunstancia correcta, como un agujero de seguridad.

    ¿Por qué no mejor leer el archivo directamente desde Python? Por
    ejemplo, en =hiloMem()=
    #+BEGIN_SRC python
    while contaro <= 10:
        f = open('/proc/meminfo', 'r')
        meminfo = f.read() # Tendrías que manejar en caso de ser >800bytes.
    #+END_SRC
    Eso te ahorraría bastante complejidad, procesos nuevos creados,
    cambios de contexto, comunicación entre procesos, y todas esas
    cosas lindas... Y si le agregamos que es un patrón que se repite
    en todo tu programa, ¡habría mucho por ganar!

| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |            1.5 |
| Cumplimiento           | Bueno (7.5)    |        |            1.5 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |           1.66 |
| Creatividad            | Bueno (7.5)    |        |            0.5 |
| Complejidad            | Bueno (7.5)    |        |            0.5 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |           1.66 |
| Documentación externa  | Excelente (10) |        |           0.66 |
| Entorno y dependencias | Excelente (10) |        |           0.66 |
| Comentarios            | Suficiente (5) |        |           0.33 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |              2 |
| Historia en Git        | Excelente (10) |        |           0.66 |
| Directorio de proyecto | Excelente (10) |        |           0.66 |
| Código Válido          | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |           1.75 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Bueno (7.5)    |        |           0.75 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |         *8.57* |
|------------------------+----------------+--------+----------------|


* Gerardo Mendoza

- Directorio de entrega :: [[./Gerardmc95/Monitor]]
- Documentación :: [[./Gerardmc95/Monitor/Documentacion.txt]]
- Lenguaje de desarrollo :: Python
- Uso primario de sincronización :: Mutex para proteger de escritura
     concurrente la terminal
- Observaciones ::
  - Tu directorio incluye tres archivos que superponen su
    funcionalidad, =MonitorBeta1.py=, =MonitorBeta.py= y
    =MonitorDeSistema.py=. Si estás usando un sistema de control de
    versiones (Git), no tiene sentido tener más de una versión; en
    caso de que lo requirieras, podrías /volver en el tiempo/ a
    cualquier commit previo. Tengo que considerarlo dentro de los
    supuestos de la segunda columna del /directorio de proyecto/.

    Abordo únicamente el último de estos tres archivos.
  - Interesante y hasta cierto punto impresionante que especificaras
    las secuencias de escape para que se viera mejor presentado en
    terminal. ¡Muy bien! Como sugerencia, te habría resultado mucho
    más simple si separaras el manejo de salida en una clase
    independiente, tal vez algo como:
    #+BEGIN_SRC python
    class Mensaje:
      def esc: return chr(27)
      def rojo: return esc + "[1;31m"
      def amarillo: return esc + "[3;33m"
      def blanco: return esc + "[3;32m"
      # (...)
      def encabezado(subsistema, descripcion):
        return rojo() + "===>" + amarillo() + subsistema + rojo() + "<===\n" + amarillo() + descripcion + blanco()
    #+END_SRC
    Con eso, en cualquiera de tus funciones podrías reemplazar las
    partes más repetitivas de tu código:
    #+BEGIN_SRC python
    m = Mensaje()
    # (...)
    def HDD():
      global semaforo
      semaforo.acquire()
      print m.encabezado("DISK", "Ficheros y carpetas en forma de árbol comenzando por la raiz")
      os.system("tree")
      semaforo.release()
    #+END_SRC
  - Dependes de la existencia de varios comandos externos, pero no
    verificas su existencia. En mi sistema:
    #+BEGIN_SRC text
    ===> DISK <===

    Ficheros y carpetas en forma de arbol comenzando por la raiz

    sh: 1: tree: not found
    ===> DISK <===

    Ficheros y carpetas en forma de arbol comenzando por la raiz

    sh: 1: tree: not found
    #+END_SRC
  - Interfaz bonita y amigable, ¡felicidades! La usabilidad es
    mejorable, pero se ve que le invertiste un buen trabajo en lograrla.


| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |              2 |
| Cumplimiento           | Excelente (10) |        |              2 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |            1.5 |
| Creatividad            | Bueno (7.5)    |        |            0.5 |
| Complejidad            | Suficiente (5) |        |           0.33 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |              2 |
| Documentación externa  | Excelente (10) |        |           0.66 |
| Entorno y dependencias | Excelente (10) |        |           0.66 |
| Comentarios            | Excleente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |           1.66 |
| Historia en Git        | Excelente (10) |        |           0.66 |
| Directorio de proyecto | Bueno (7.5)    |        |            0.5 |
| Código Válido          | Bueno (7.5)    |        |            0.5 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |           1.75 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Bueno (75)     |        |           0.75 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |         *8.91* |
|------------------------+----------------+--------+----------------|


* Josué Quiñones y Ángel Vázquez

- Directorio de entrega :: [[./Monitor/]]
- Documentación :: [[/.Monitor/README.md]]
- Lenguaje de desarrollo :: C++
- Uso primario de sincronización :: Mutex para los buffers con la
     información recabada; señalización vía =emit= / =connect= de señal
- Observaciones ::
  - La documentación (el README.md) no incluye una descripción de la
    funcionalidad del programa (lógica de operación)
  - La biblioteca gráfica que manejan es Qt, cierto. Sin embargo, el
    entorno que describen para poder compilar y lanzar el programa es
    el Qt Creator; me tomó un poco comprender a lo que se
    referían. Mencionan como requisito "duro" la versión 5.7.0 de Qt,
    pero funciona perfectamente con una versión menor (tengo instalado
    Qt Creator 4.1.0, la biblioteca Qt en un estado un poco mixto
    entre 5.5.0 y 5.6.0)
  - Algunos de los archivos (=interruptwindow=, =interruptsthread=,
    =mainwindow=, =meminfo=, =readerthread=) llevan comentarios, otros
    no (=dispositivosthread=, =dispositivoswindow=, =information=,
    =main=). Y si bien la lógica de varios de estos es bastante
    similar a la de los primeros (y =main= es francamente trivial),
    más que saltarse el comentario, correspondería pensar si podemos
    ahorrar la duplicación: ¿Podrían haber hecho una clase =window=,
    que generalizara el comportamiento de las tres ventanas,
    parametrizando qué información mostraría?
  - ¡Muy bueno que describan lo que debe mostrar cada uno de los
    archivos que presentan!
  - Podrían ganar un poco en usabilidad si utilizaran un tipo de letra
    =monoespaciado=, dado que en caso contrario se rompe la alineación
    tabular, o que en todo caso (con conocimiento del formato que
    reciben) lo separaran y presentaran en una tabla de Qt
  - Tras construir el proyecto, QtCreator arroja un directorio
    =build-MonitorSistema-Desktop-Debug=. Como interesado en el
    proyecto, me conviene mantenerlo para ahorrar tiempo en mis
    compilaciones posteriores, pero me /ensucia/ el Git. ¡Deberían
    listarlo en un =.gitignore=!

| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |              2 |
| Cumplimiento           | Excelente (10) |        |              2 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |              2 |
| Creatividad            | Excelente (10) |        |           0.66 |
| Complejidad            | Excelente (10) |        |           0.66 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |            1.5 |
| Documentación externa  | Bueno (7.5)    |        |            0.5 |
| Entorno y dependencias | Bueno (7.5)    |        |            0.5 |
| Comentarios            | Bueno (7.5)    |        |            0.5 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |           1.82 |
| Historia en Git        | Excelente (10) |        |           0.66 |
| Directorio de proyecto | Bueno (7.5)    |        |            0.5 |
| Código Válido          | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |              2 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Excelente (10) |        |              1 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |         *9.32* |
|------------------------+----------------+--------+----------------|


* Jesús García y Andrés López

- Directorio de entrega :: [[./Monitordesistema]]
- Documentación :: [[./Monitordesistema/Escrito.docx]]
- Lenguaje de desarrollo :: Visual BASIC / C#
- Uso primario de sincronización :: No encontrado
- Observaciones ::
  - Uff... ¡Me hicieron sudar para instalar el entorno de
    construcción! Y tengo que admitir mi derrota: Conseguí montar una
    máquina virtual con Windows 7 y Visual Studio 2010... ¡Pero ni
    siquiera se molestó en abrir el proyecto por haberse desarrollado
    en una versión más nueva!
  - Uso de Git: Una de las principales razones de manejar un sistema
    de seguimiento de cambios (como lo es Git) es que con él ya no
    requieren los directorios por versión, como ustedes lo
    enviaron. Es mucho más fácil (para el desarrollo y para la
    evaluación) tener un único directorio, con la historia completa de
    cambios contenida.
    - Limito mi evaluación al directorio =VERSION4=, los demás los omito
      por completo.
  - Incluyen muchos archivos autogenerados. ¿Son todos ellos
    necesarios?
    - Incluyen subdirectorios derivados de la construcción,
      como =bin= y =obj=, incluyendo archivos objeto ya compilados (como
      =WindowsApplication4.exe=.
  - No veo ningún manejo de mecanismos de sincronización. Posiblemente
    (no estoy seguro) sí de manejo de más de un hilo de ejecución,
    pero no de sincronización. Si efectivamente los manejan, ¡por
    favor háganmelo saber! (repercute bastante en su calificación)
  - Si entiendo correctamente, todo el "andamiaje" en VisualBASIC es
    generado por el entorno de desarrollo, y únicamente el archivo
    fuente =proce.cs= es de ustedes, ¿correcto? (de no ser así,
    comuníquenmelo y reviso la calificación).
    - No, no creo que sea únicamente así :-( ¿La lógica de obtención
      de datos es lo que tienen en =labels.vb=, al reaccionar a
      =Button2.Click()=?
  - Claro... Sería mucho mejor si esto estuviera propiamente
    documentado. No hay prácticamente nada de documentación relativa
    al entorno y dependencias :-(
    - Y ya hablando de documentación, tampoco incluyen nada respecto a
      la lógica que siguan para resolver el problema
    - No incluyen instrucciones de construcción, y yo fui incapaz de
      compilar o ejecutar el proyecto. Confío en que es por impericia
      mía — Les doy 75% en ese rubro, pero les pido que me lo muestren
      funcionando en su equipo.
  - Hicieron un muy buen trabajo de buscar fuentes de datos del
    sistema vía API dentro de los espacios de nombres =My.Computer=,
    =Mu.User=, =System=, etc. ¡Interesante!
  - Llama mi atención que si bien este proyecto fue creado y
    gestionado por un entorno de desarrollo integrado (IDE) no maneja
    en automático indentación y algunos detalles similares. Ejemplo:

    #+BEGIN_SRC C
      namespace ProcessKiller
      { 
          public partial class proce : Form 
      {
          public proce() 
          { 
    #+END_SRC

    La lógica me indicaría que todo el contenido del proyecto debería
    estar indentada un nivel más...

| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |              1 |
| Cumplimiento           | Suficiente (5) |        |              1 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |              2 |
| Creatividad            | Excelente (10) |        |           0.66 |
| Complejidad            | Excelente (10) |        |           0.66 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |           1.16 |
| Documentación externa  | Bueno (7.5)    |        |            0.5 |
| Entorno y dependencias | Suficiente (5) |        |           0.33 |
| Comentarios            | Suficiente (5) |        |           0.33 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |           1.33 |
| Historia en Git        | Bueno (7.5)    |        |            0.5 |
| Directorio de proyecto | Suficiente (5) |        |           0.33 |
| Código Válido          | Bueno (7.5)    |        |            0.5 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |            1.5 |
| Estructura             | Bueno (7.5)    |        |           0.75 |
| Nomenclatura           | Bueno (7.5)    |        |           0.75 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |            *7* |
|------------------------+----------------+--------+----------------|


* Abraham Ortega y Bidkar Páez

- Directorio de entrega :: [[./OrtegayPaez]]
- Documentación ::  [[./OrtegayPaez/DOCUMENTACION.pdf]]
- Lenguaje de desarrollo :: Python
- Uso primario de sincronización :: Manejo de mutexes, =QtCore.SIGNAL=
     para notificación de eventos; notificación de progreso por
     indicadores GUI
- Observaciones ::
  - ¡Excelente proyecto! Verdaderamente, ¡felicidades! Se nota que
    trabajaron con dedicación
  - El polimorfismo no es particular de Java, es parte del
    planteamiento básico de la orientación a objetos — ¡y es una pena
    que no estemos más acostumbrados a usarlo!
  - Obviamente, hay espacio para refinaciones posteriores. Por
    ejemplo, resulta incómodo que si estás consultando la lista de
    proceso (particularmente esa por ser la de mayor frecuencia de
    cambios) se redibuje completa. Podrían estructurarlo alrededor de
    un diccionario por PID, y actualizar campos específicos. Pero es
    simplemente cosa de querer buscar detalles...
  - ¡Ah! Falta algo importante desde el punto de vista de interfaz
    usuario: ¿Cómo me salgo del programa? ¡Únicamente matándolo a
    traición!


| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |              2 |
| Cumplimiento           | Excelente (10) |        |              2 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |                |
| Creatividad            | Excelente (10) |        |           0.66 |
| Complejidad            | Excelente (10) |        |           0.66 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |              2 |
| Documentación externa  | Excelente (10) |        |           0.66 |
| Entorno y dependencias | Excelente (10) |        |           0.66 |
| Comentarios            | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |              2 |
| Historia en Git        | Excelente (10) |        |           0.66 |
| Directorio de proyecto | Excelente (10) |        |           0.66 |
| Código Válido          | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |              2 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Excelente (10) |        |              1 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |           *10* |
|------------------------+----------------+--------+----------------|


* Max Sánchez

- Directorio de entrega :: [[./PMax_01]]
- Documentación :: [[./PMax_01/documentacion.txt]]
- Lenguaje de desarrollo :: Python
- Uso primario de sincronización :: Mutex protegiendo la lógica
     interna de =obtenerDatos()=; esperar a la finalización de hilos
     derivados mediante =join()=
- Observaciones ::
  - Cumples formalmente con que el programa sea multi-hilos, pero
    mantienes la ejecución plenamente secuencial, sin aprovechar en
    ningún momento el paralelismo. Llegas a emplear un mutex, pero
    resulta innecesario porque es en un único punto, no hay
    concurrencia que controlar.
  - Logras un muy buen conjunto de información de varias fuentes
    distintas, y lo presentas de forma muy coherente. ¡Bien!
  - Documentación externa: No incluye lógica de operación ni ejemplos
    de invocación; no mencionas entorno o dependencias (quedó a mi
    interpretación darme cuenta que no funcionaba por ser Python3,
    falla silenciosamente en Python2).
  - Tip: Tu uso de archivos temporales (=cheat.txt=, =li.txt=,
    =procAc.txt=, etc.) resulta peligroso, puede llevarte a
    importantes agujeros de seguridad relacionados particularmente con
    la concurrencia: Si alguien sabe qué archivos vas a emplear, puede
    medir el tiempo, y sobreescribirlos a medio camino entre su
    escritura y lectura. Además, como ejecutas con privilegios
    elevados (y no verificas preexistencia), puede atacarse por medio
    de la creación de ligas simbólicas para sobreescribir archivos
    arbitrarios en el sistema.

    Te sugiero asomarte a la [[https://docs.python.org/3.5/library/tempfile.html][documentación del módulo tempfile]] para
    mayores detalles.
  - ¡Tu programa elimina archivos de más! ¡Qué bueno que no lo ejecuté
    en otro lugar! Al salir, pregunta:
    #+BEGIN_SRC text
    Es probable que durante la ejecucion de este programa
    se crearan archivos extra, quieres eliminarlos?(s/n): s
    #+END_SRC
    Acto seguido, se había eliminado tu =documentacion.txt=.
  - Incluyes como parte del proyecto subido a Git un archivo compilado
    a bytecode de python, =__pycache__/lib.cpython-35.pyc=. Cuando yo
    ejecuto tu programa, éste se vuelve a compilar y se modifica,
    "ensuciando" mi árbol Git. ¡Deberías haberlo excluído con
    =.gitignore=! (y, ya que estamos, incluir también todos tus
    =*.txt= generados)
  - Un error muy común que observo es que ven como separados el paso
    de escribir el código del de comentarlo. ¡Debe ser realizado en
    conjunto! Sólo eso explica comentarios que indican que olvidaste
    ya lo que pensabas al desarrollar:
    #+BEGIN_SRC python
    ##apartir de aqui es probable que sea dificil de entender
    #+END_SRC
  - Mismo comentario que el que le hice a Alberto: Desde un programa,
    llamar a =cat= como programa para averiguar el contenido de un
    archivo (como lo haces en varias ocasiones) es un desperdicio
    burocrático de recursos... E incluso puede verse, en la
    circunstancia correcta, como un agujero de seguridad.

    ¿Por qué no mejor leer el archivo directamente desde Python? Por
    ejemplo, en =monH()=, podrías hacer:
    #+BEGIN_SRC python
    arch = open('/proc/sched_debug', 'r')
    #+END_SRC
    Eso te ahorraría bastante complejidad, procesos nuevos creados,
    cambios de contexto, comunicación entre procesos, y todas esas
    cosas lindas... Y si le agregamos que es un patrón que se repite
    en todo tu programa, ¡habría mucho por ganar!
  - El significado de /tiempo real/ es muy preciso, y es absoluamente
    distinto de lo que implementas como tu opción #4. Claro, no te lo
    puedo juzgar, porque no lo hemos visto aún ;-) Pero no puedo
    dejarlo de anotar.

| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |            1.5 |
| Cumplimiento           | Bueno (7.5)    |        |            1.5 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |              2 |
| Creatividad            | Excelente (10) |        |           0.66 |
| Complejidad            | Excelente (10) |        |           0.66 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |              1 |
| Documentación externa  | Suficiente (5) |        |           0.33 |
| Entorno y dependencias | Suficiente (5) |        |           0.33 |
| Comentarios            | Suficiente (5) |        |           0.33 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |           1.66 |
| Historia en Git        | Bueno (7.5)    |        |            0.5 |
| Directorio de proyecto | Bueno (7.5)    |        |            0.5 |
| Código Válido          | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |           1.75 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Bueno (7.5)    |        |           0.75 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |         *7.94* |
|------------------------+----------------+--------+----------------|


* Sebastián Aguilar

- Directorio de entrega :: [[./Penserbjorne/MonitorSistema]]
- Documentación :: [[./Penserbjorne/MonitorSistema/Readme.md]], [[./Penserbjorne/MonitorSistema/Documentacion/MonitorSistema.pdf]]
- Lenguaje de desarrollo :: C++
- Uso primario de sincronización :: Los hilos =monitor_memoria=,
     =monitor_stat= y =monitor_diskstats= son despertados por un
     temporizador cada segundo
- Observaciones ::
  - El programa no compilaba, por una dependencia no documentada sobre
    QtCharts en el =main.cpp=; hizo falta realizar la siguiente
    modificación para que compilara.
    #+BEGIN_SRC diff

      --- a/proyectos/01/Penserbjorne/MonitorSistema/MonitorSistema_Aplicacion/main.cpp
      +++ b/proyectos/01/Penserbjorne/MonitorSistema/MonitorSistema_Aplicacion/main.cpp
      @@ -7,9 +7,6 @@
       #include "mainwindow.h"
       #include <QApplication>
 
      -#include <QtCharts/QChartView>
      -#include <QtCharts/QPieSeries>
      -#include <QtCharts/QPieSlice>
       #include <QtCore/QDebug>
 
       using namespace std;
    #+END_SRC
    Cabe mencionar que es una dependencia... Que no se usa en el
    programa :-/

  - El programa es multihilos, sin embargo, el uso de la
    sincronización es apenas rudimentario: Una notificación una vez
    por segundo para tres de los monitores (los que atienden a
    información cambiante). En términos de lo estudiado, manejas
    paralelismo, pero no concurrencia.

  - ¡Me gusta cómo presentas la información! Muy buena interfaz de
    usuario. Ahora... Para que fuera más útil:

    - La tabla donde presentas la información de =cpuinfo= es muy
      ancha, y prácticamente toda la información es repetida entre los
      renglones. ¿No sería mejor presentar en forma tabular únicamente
      la información que difiera?

    - Y en la página de =stat / meminfo=, presentas dos listados. El de
      =stat= se ve bien, pero el de =meminfo= se beneficiaría mucho de
      estar alineado de forma tabular, como el de =cpuinfo=. Sí,
      requiere hacer un procesamiento del archivo, pero... Nada del otro
      mundo :)

      - Detalle de implementación: En =struct_cpuinfo.cpp= listas cada
        uno de los renglones que te entrega =/proc/cpuinfo= en
        arquitectura x86. Ahora... ¿Cómo se comportaría el programa
        en, digamos, una máquina ARM? Una de las máquinas que tengo me
        entrega esta información, bastante distinta de lo que tu
        programa espera:

	#+BEGIN_SRC text
          $ cat /proc/cpuinfo 
          processor       : 0
          model name      : ARMv7 Processor rev 2 (v7l)
          BogoMIPS        : 1587.20
          Features        : swp half thumb fastmult vfp edsp thumbee vfpv3 tls idiva idivt vfpd32 lpae 
          CPU implementer : 0x56
          CPU architecture: 7
          CPU variant     : 0x2
          CPU part        : 0x584
          CPU revision    : 2

          processor       : 1
          model name      : ARMv7 Processor rev 2 (v7l)
          BogoMIPS        : 1594.36
          Features        : swp half thumb fastmult vfp edsp thumbee vfpv3 tls idiva idivt vfpd32 lpae 
          CPU implementer : 0x56
          CPU architecture: 7
          CPU variant     : 0x2
          CPU part        : 0x584
          CPU revision    : 2

          processor       : 2
          model name      : ARMv7 Processor rev 2 (v7l)
          BogoMIPS        : 1594.36
          Features        : swp half thumb fastmult vfp edsp thumbee vfpv3 tls idiva idivt vfpd32 lpae 
          CPU implementer : 0x56
          CPU architecture: 7
          CPU variant     : 0x2
          CPU part        : 0x584
          CPU revision    : 2

          processor       : 3
          model name      : ARMv7 Processor rev 2 (v7l)
          BogoMIPS        : 1594.36
          Features        : swp half thumb fastmult vfp edsp thumbee vfpv3 tls idiva idivt vfpd32 lpae 
          CPU implementer : 0x56
          CPU architecture: 7
          CPU variant     : 0x2
          CPU part        : 0x584
          CPU revision    : 2

          Hardware        : Marvell Armada 370/XP (Device Tree)
          Revision        : 0000
          Serial          : 0000000000000000
	#+END_SRC
	Corriendo en esta máquina, la tabla =CPU_INFO= aparece
        completamente en blanco.

    - En la pestaña disco, ¿de dónde obtienes la lista de registros a
      mostrar? ¿Por qué lo limitas a las partciones del primer disco?
      (lo corrí en una computadora con tres discos... Claro, puede que
      no se te ocurriera porque se sale del uso común)

  - Respecto a tu documentación:

    - En el README mencionas que es un /monitor en tiempo real/. No
      habíamos visto aún el tema, pero en este momento espero que
      reconozcas que /no es/ tiempo real — simplemente se actualiza
      periódicamente.

    - No mencionas la /lógica de operación/ en la documentación
      (requisito explícito)

  - Respecto a la entrega:

    - Construir el proyecto genera el directorio de depuración
      =build-MonitorSistema_Aplicacion-Desktop-Debug/=. Debería estar
      en un =.gitignore=.


| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |            1.5 |
| Cumplimiento           | Bueno (7.5)    |        |            1.5 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |              2 |
| Creatividad            | Excelente (10) |        |           0.66 |
| Complejidad            | Excelente (10) |        |           0.66 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |           1.82 |
| Documentación externa  | Bueno (7.5)    |        |            0.5 |
| Entorno y dependencias | Excelente (10) |        |           0.66 |
| Comentarios            | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |           1.66 |
| Historia en Git        | Excelente (10) |        |           0.66 |
| Directorio de proyecto | Bueno (7.5)    |        |            0.5 |
| Código Válido          | Bueno (7.5)    |        |            0.5 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |              2 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Excelente (10) |        |              1 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |              9 |
|------------------------+----------------+--------+----------------|


* Erik Sanabria

- Directorio de entrega :: [[./Proyecto_Erik_Sebastian]]
- Documentación :: [[./Proyecto_Erik_Sebastian/Readme.md]]
- Lenguaje de desarrollo :: C++
- Uso primario de sincronización :: Maneja una variable de tipo
     =atomic<bool>= para señalizar si ya no hace falta continuar con
     el monitoreo (esto es, si el GUI terminó) para que el recolector
     de datos también termine.
- Observaciones ::
  - Me tuviste un buen rato rascándome la cabeza, sin entender dónde
    estaba la lógica de la aplicación... ¡Hasta que la encontré dentro
    de los encabezados! La convención en C y los lenguajes derivados
    de él es que toda la lógica va en los archivos =*.c=, y en los
    archivos =*.h= únicamente van las declaraciones necesarias para
    que terceros liguen contra éste.
  - Hacer el /parseo/ de la salida textual de un comando en C++ es
    bastante doloroso... ¿No crees que te hubiera resultado mucho más
    sencillo (y tal vez hasta más rápido y confiable) leer los
    parámetros de =/proc/*= que de =ps aux=?
  - Tip: Tu uso de archivos temporales (=procesos.txt=, =procesos2.txt=,
    =procAc.txt=, etc.) resulta peligroso, puede llevarte a
    importantes agujeros de seguridad relacionados particularmente con
    la concurrencia: Si alguien sabe qué archivos vas a emplear, puede
    medir el tiempo, y sobreescribirlos a medio camino entre su
    escritura y lectura. Además, como ejecutas con privilegios
    elevados (y no verificas preexistencia), puede atacarse por medio
    de la creación de ligas simbólicas para sobreescribir archivos
    arbitrarios en el sistema.

    Es muy recomendable seguir una práctica como la siguiente:
    #+BEGIN_SRC C++
    char *tmpname = strdup("/tmp/tmpfileXXXXXX");
    mkstemp(tmpname);
    ofstream f(tmpname);
    #+END_SRC

    - Ahora que... Para el uso que das, sería mejor todavía (en vez de
      manejar archivos temporales) el manejar a tu =ps aux= leyendo
      directamente de él, sin crear archivos temporales innecesarios.

  - Un uso muy limitado de sincronización. El manejo de =atomic<bool>=
    es ingenioso, y valdría la pena presentárselo al grupo,
    pero... ¿Sólo pudiste meter sincronización de una bandera para
    resolver el proyecto? ¡Se antojaba mucho más!

| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |            1.5 |
| Cumplimiento           | Bueno (7.5)    |        |            1.5 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |            1.5 |
| Creatividad            | Bueno (7.5)    |        |            0.5 |
| Complejidad            | Suficiente (5) |        |           0.33 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |           1.82 |
| Documentación externa  | Excelente (10) |        |           0.66 |
| Entorno y dependencias | Excelente (10) |        |           0.66 |
| Comentarios            | Bueno (7.5)    |        |            0.5 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |           1.82 |
| Historia en Git        | Excelente (10) |        |           0.66 |
| Directorio de proyecto | Bueno (7.5)    |        |            0.5 |
| Código Válido          | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |        |            1.5 |
| Estructura             | Suficiente (5) |        |            0.5 |
| Nomenclatura           | Excelente (10) |        |              1 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |         *8.14* |
|------------------------+----------------+--------+----------------|


* Yaxkin Sánchez

- Directorio de entrega :: [[./YaxkinSanchez]]
- Documentación :: [[./YaxkinSanchez/MiniMonitor.py]]
- Lenguaje de desarrollo :: Python
- Uso primario de sincronización :: Señalización para actualizar la
     interfaz una vez que los hijos están listos; mutex protegiendo
     contador global de hilos listos
- Observaciones ::
  - ¡Excelente proyecto! Felicidades por un muy buen desarrollo, y por
    un excelente uso de Git para llevarlo.
  - En varios puntos, estás empleando estructuras demasiado rígidas,
    que dificultarían extender tu programa a futuro. Pongo un ejemplos
    que me pareció particularmente revelador, aunque hay más. Bien al
    principio:
    #+BEGIN_SRC python
    #Variables útiles para algunas funciones
    no_funciones_monitor = 15
    #+END_SRC
    Y unas 300 líneas más abajo:
    #+BEGIN_SRC python
    #Hilos que colocan los datos en la interfaz
    def lanzaHilos(screen):
	threading.Thread(target=cpuUsuario, args=[screen]).start()
	threading.Thread(target=cpuSistema, args=[screen]).start()
	threading.Thread(target=cpuInactivo, args=[screen]).start()
	threading.Thread(target=memTotal, args=[screen]).start()
	threading.Thread(target=memLibre, args=[screen]).start()
	threading.Thread(target=memDisponible, args=[screen]).start()
	threading.Thread(target=memUso, args=[screen]).start()
	threading.Thread(target=memSwapTotal, args=[screen]).start()
	threading.Thread(target=memSwapLibre, args=[screen]).start()
	threading.Thread(target=memSwapUso, args=[screen]).start()
	threading.Thread(target=tiempoFuncionamiento, args=[screen]).start()
	threading.Thread(target=tiempoInactivo, args=[screen]).start()
	threading.Thread(target=numProcesos, args=[screen]).start()
	threading.Thread(target=numProcesosEjecucion, args=[screen]).start()
	threading.Thread(target=procesos, args=[screen]).start()
    #+END_SRC
    De entrada... ¿Cómo sabe el lector que ese =15= de
    =no_funciones_monitor= tiene algo que ver con el número de hilos,
    como no sea entendiendo tu manejo de =contador_hilos=? ¿Cómo te
    vas a acordar de actualizarlo siempre que haga falta?

    Tal vez sería mejor (en este caso en particular y sin pensarle
    mucho) hacer una variable global =hilos=:
    #+BEGIN_SRC python
    hilos = [cpuUsuario, cpuSistema, cpuInactivo, memTotal] # mas lo que falte
    no_funciones_monitor = len(hilos)
    # (...)
    def lanzaHilos(screen):
      for h in hilos:
        threading.Thread(target=h, args=[screen]).start()
    #+END_SRC
  - Caes en el mismo patrón de abuso de procesos cuando podrías usar
    simple acceso a archivo que algunos de tus compañeros: Desde un
    programa, llamar a =cat= (o =grep= directamente) como programa
    para averiguar el contenido de un archivo (como lo haces en varias
    ocasiones) es un desperdicio burocrático de recursos... E incluso
    puede verse, en la circunstancia correcta, como un agujero de
    seguridad.

    ¿Por qué no mejor leer el archivo directamente desde Python? En tu
    programa llamas 20 veces a =commands.getoutput()= siguiendo la
    misma lógica. Por ejemplo,
    #+BEGIN_SRC python
    modelo = commands.getoutput("cat /proc/cpuinfo | grep -e 'model\ name*'")
    #+END_SRC

    Esto podrías reemplazarlo por:
    #+BEGIN_SRC python
    import re # Expresiones regulares – Todo lo que hacen grep + sed
    modelo = []
    f.open('/proc/cpuinfo', 'r')
    for line in f.readlines():
      if p.match(line):
        modelo.append( re.sub('model.name.*: ', '', i) )
    #+END_SRC

    Eso te ahorraría bastante complejidad, procesos nuevos creados,
    cambios de contexto, comunicación entre procesos, y todas esas
    cosas lindas... Y si le agregamos que es un patrón que se repite
    en todo tu programa, ¡habría mucho por ganar!

    Ojo, en este último ejemplo mantengo un bug que tienes, que
    concatena a todas las repeticiones del modelo del CPU, una por
    núcleo. ¡Deberías tomar la primera únicamente! :-)

| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |              2 |
| Cumplimiento           | Excelente (10) |        |              2 |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |              2 |
| Creatividad            | Excelente (10) |        |           0.66 |
| Complejidad            | Excelente (10) |        |           0.66 |
| Interfaz usuario       | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |              2 |
| Documentación externa  | Excelente (10) |        |           0.66 |
| Entorno y dependencias | Excelente (10) |        |           0.66 |
| Comentarios            | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |              2 |
| Historia en Git        | Excelente (10) |        |           0.66 |
| Directorio de proyecto | Excelente (10) |        |           0.66 |
| Código Válido          | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |        |              2 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Excelente (10) |        |              1 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |           *10* |
|------------------------+----------------+--------+----------------|


* David Pérez

- Directorio de entrega :: [[./PerezMartinez]]
- Documentación :: [[./PerezMartinez/README.md]]
- Lenguaje de desarrollo :: Python
- Uso primario de sincronización :: Señalización entre los tres hilos;
     temporizador sobre la ventana principal para su constante
     actualización
- Observaciones ::
  - Interfaz usuario: Este es un caso claro de cuándo una interfaz de
    línea de comando puede ser superior a una interfaz gráfica: Dado
    que estás presentando información tabular (las magnitudes
    correspondientas a I/O de discos), el tener un tipo de letra de
    ancho variable entorpece la comprensión. Para hacerlo en un
    entorno gráfico, te convendría cambiar de tipo de letra, o
    utilizar una tabla; para Python con =tkinter=, podrías haber usado
    [[http://tkinter.unpythonic.net/wiki/TkTable][TkTable]].
  - Comentarios excesivos. Debes comentar lo que no es obvio. Comentar
    de más obscurece el panorama más que aclararlo.
  - Hubo menos de cinco commits, pero creo que por el detalle que tuve
    que rescatar del /pull request/ errado.

| *Rubro*                | *Calificación* | *Peso* | *Calificación* |
|------------------------+----------------+--------+----------------|
| *Requisitos*           |                |    0.2 |              2 |
| Cumplimiento           |                |        |                |
|------------------------+----------------+--------+----------------|
| *Proyecto*             |                |    0.2 |           1.82 |
| Creatividad            | Excelente (10) |        |           0.66 |
| Complejidad            | Excelente (10) |        |           0.66 |
| Interfaz usuario       | Bueno (7.5)    |        |            0.5 |
|------------------------+----------------+--------+----------------|
| *Documentación*        |                |    0.2 |           1.82 |
| Documentación externa  | Excelente (10) |        |           0.66 |
| Entorno y dependencias | Excelente (10) |        |           0.66 |
| Comentarios            | Bueno (7.5)    |        |            0.5 |
|------------------------+----------------+--------+----------------|
| *Entrega*              |                |    0.2 |           1.82 |
| Historia en Git        | Bueno (7.5)    |        |            0.5 |
| Directorio de proyecto | Excelente (10) |        |           0.66 |
| Código Válido          | Excelente (10) |        |           0.66 |
|------------------------+----------------+--------+----------------|
| *Legibilidad*          |                |    0.2 |            1.5 |
| Estructura             | Excelente (10) |        |              1 |
| Nomenclatura           | Bueno (7.5)    |        |           0.75 |
|------------------------+----------------+--------+----------------|
| *Total*                |                |        |              9 |
|------------------------+----------------+--------+----------------|


* Miguel Vargas

- Directorio de entrega :: [[./Miguel_Vargas/]]
- Documentación :: [[./Miguel_Vargas/documento.pdf]]
- Lenguaje de desarrollo :: C
- Uso primario de sincronización :: No es utilizada
- Observaciones :: 
  - Entrega extemporánea: El /commit/ de entrega fue realizado el 8 de
    octubre, 10 días después de la fecha de entrega; se califica sobre
    0.5.
  - Documentación:
    - Es muy bueno que emplees /doxygen/, pero la documentación
      generada no cumple con los criterios de calificación que
      describe la rúbrica. Doxygen debe verse como /parte/ de tu
      documentación, en ningún momento reemplaza a tu documentación
      para el usuario (es documentación para el programador).
    - Incluyes un comprimido =documentos.rar=, con los fuentes del
      documento en /doxygen/ para HTML y LaTeX que entregas. Cuando
      trabajas en Git, evita usar archivos comprimidos, que no ganas
      nada, sólo trae inconveniencia. Además, estos fuentes
      intermedios son irrelevantes para el proyecto — podrías haberlos
      omitido.
  - El código no es válido. Al agregar las cadenas de /doxygen/
    agregaste la apertura de bloque (las llaves) para las funciones
    =listarProc()= y =elMasGrande()=.
  - Manejas procesos simultáneos (lanzados vía =fork()=), pero no hay
    sincronización entre ellos; únicamente "te encomiendas" a que las
    funciones que llamas como proceso en paralelo terminen antes de
    que el usuario haga algo más.

| *Rubro*                | *Calificación*   | *Peso* | *Calificación* |
|------------------------+------------------+--------+----------------|
| *Requisitos*           |                  |    0.2 |              1 |
| Cumplimiento           | Suficiente (5)   |        |              1 |
|------------------------+------------------+--------+----------------|
| *Proyecto*             |                  |    0.2 |           1.82 |
| Creatividad            | Bueno (7.5)      |        |            0.5 |
| Complejidad            | Excelente (10)   |        |           0.66 |
| Interfaz usuario       | Excelente (10)   |        |           0.66 |
|------------------------+------------------+--------+----------------|
| *Documentación*        |                  |    0.2 |              1 |
| Documentación externa  | Insuficiente (0) |        |              0 |
| Entorno y dependencias | Suficiente (5)   |        |           0.33 |
| Comentarios            | Excelente (10)   |        |           0.66 |
|------------------------+------------------+--------+----------------|
| *Entrega*              |                  |    0.2 |           1.33 |
| Historia en Git        | Suficiente (5)   |        |           0.33 |
| Directorio de proyecto | Bueno (7.5)      |        |            0.5 |
| Código Válido          | Bueno (7.5)      |        |            0.5 |
|------------------------+------------------+--------+----------------|
| *Legibilidad*          |                  |    0.2 |           1.75 |
| Estructura             | Bueno (7.5)      |        |           0.75 |
| Nomenclatura           | Excelente (10)   |        |              1 |
|------------------------+------------------+--------+----------------|
| *Total*                | 6.9 × 0.5        |        |            3.5 |
|------------------------+------------------+--------+----------------|

